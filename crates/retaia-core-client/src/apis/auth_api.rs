/*
 * Retaia Core API
 *
 * Normative OpenAPI v1 for Retaia Core (minor features up to v1.1).  This API coordinates assets, processing jobs and agents. Agents are non-reliable by design. Jobs may remain pending indefinitely if no compatible agent is available. AI-powered features are planned for v1.1+ and are out of v1 conformance scope.
 *
 * The version of the OpenAPI document: 1.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::apis::ContentType;
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait AuthApi: Send + Sync {
    /// GET /app/features
    ///
    /// Returns global app switches (`app_feature_enabled`). Also returns dependency/escalation metadata for deterministic client behavior. Effective global availability requires Core `feature_flags` AND `app_feature_enabled`. Normative gate: when `app_feature_enabled.features.ai=false`, `client_kind=MCP` is disabled at runtime. Admin-only endpoint. Runtime payload contract is stable: `app_feature_enabled`, `feature_governance`, `core_v1_global_features`.
    async fn app_features_get(
        &self,
    ) -> Result<models::AppFeaturesResponse, Error<AppFeaturesGetError>>;

    /// PATCH /app/features
    ///
    /// Updates effective app switches (`app_feature_enabled`). Admin-only operation.
    async fn app_features_patch<'app_features_update_request>(
        &self,
        app_features_update_request: models::AppFeaturesUpdateRequest,
    ) -> Result<models::AppFeaturesResponse, Error<AppFeaturesPatchError>>;

    /// GET /app/policy
    ///
    /// Returns runtime `server_policy` including `feature_flags`. This endpoint is the canonical runtime policy transport for UI_WEB, UI_MOBILE, AGENT, and MCP clients. Clients may optionally send their supported feature-flags contract version for compatibility negotiation.
    async fn app_policy_get<'client_feature_flags_contract_version>(
        &self,
        client_feature_flags_contract_version: Option<&'client_feature_flags_contract_version str>,
    ) -> Result<models::AppPolicyResponse, Error<AppPolicyGetError>>;

    /// POST /auth/2fa/disable
    ///
    ///
    async fn auth2fa_disable_post<'auth2fa_otp_request>(
        &self,
        auth2fa_otp_request: models::Auth2faOtpRequest,
    ) -> Result<(), Error<Auth2faDisablePostError>>;

    /// POST /auth/2fa/enable
    ///
    ///
    async fn auth2fa_enable_post<'auth2fa_otp_request>(
        &self,
        auth2fa_otp_request: models::Auth2faOtpRequest,
    ) -> Result<models::Auth2faEnableResponse, Error<Auth2faEnablePostError>>;

    /// POST /auth/2fa/recovery-codes/regenerate
    ///
    ///
    async fn auth2fa_recovery_codes_regenerate_post(
        &self,
    ) -> Result<models::Auth2faRecoveryCodesResponse, Error<Auth2faRecoveryCodesRegeneratePostError>>;

    /// POST /auth/2fa/setup
    ///
    /// Starts TOTP enrollment for external authenticator apps (Authy, Google Authenticator, 1Password, etc.). Returns provisioning material (`otpauth://` URI and secret) to be confirmed by `/auth/2fa/enable`.
    async fn auth2fa_setup_post(
        &self,
    ) -> Result<models::Auth2faSetupResponse, Error<Auth2faSetupPostError>>;

    /// POST /auth/clients/{client_id}/revoke-token
    ///
    /// Admin-only endpoint for base UI operations. Invalidates active bearer token(s) for the targeted technical client.
    async fn auth_clients_client_id_revoke_token_post<'client_id>(
        &self,
        client_id: &'client_id str,
    ) -> Result<models::AuthRevokeClientTokenResponse, Error<AuthClientsClientIdRevokeTokenPostError>>;

    /// POST /auth/clients/{client_id}/rotate-secret
    ///
    /// Admin-only operation. Rotates secret key for one client and invalidates active bearer token(s).
    async fn auth_clients_client_id_rotate_secret_post<'client_id>(
        &self,
        client_id: &'client_id str,
    ) -> Result<
        models::AuthRotateClientSecretResponse,
        Error<AuthClientsClientIdRotateSecretPostError>,
    >;

    /// POST /auth/clients/device/cancel
    ///
    ///
    async fn auth_clients_device_cancel_post<'auth_device_cancel_request>(
        &self,
        auth_device_cancel_request: models::AuthDeviceCancelRequest,
    ) -> Result<models::AuthDeviceCancelResponse, Error<AuthClientsDeviceCancelPostError>>;

    /// POST /auth/clients/device/poll
    ///
    /// Polls authorization status for a previously started device flow. On approval, returns one-shot `secret_key`.
    async fn auth_clients_device_poll_post<'auth_device_poll_request>(
        &self,
        auth_device_poll_request: models::AuthDevicePollRequest,
    ) -> Result<models::AuthDevicePollResponse, Error<AuthClientsDevicePollPostError>>;

    /// POST /auth/clients/device/start
    ///
    /// Starts a browser-assisted authorization flow (GitHub-style) for `AGENT`/`MCP`. User validation (and optional 2FA) happens via `verification_uri`. Runtime gate: when `app_feature_enabled.features.ai=false`, `client_kind=MCP` MUST be rejected.
    async fn auth_clients_device_start_post<'auth_device_start_request>(
        &self,
        auth_device_start_request: models::AuthDeviceStartRequest,
    ) -> Result<models::AuthDeviceStartResponse, Error<AuthClientsDeviceStartPostError>>;

    /// POST /auth/clients/token
    ///
    /// Exchanges `(client_id, secret_key)` for a bearer token. Normative rule: one active token per technical client_id; minting a new token revokes the previous one. This endpoint is for technical non-interactive clients only. Runtime gate: when `app_feature_enabled.features.ai=false`, `client_kind=MCP` MUST be rejected.
    async fn auth_clients_token_post<'auth_client_token_request>(
        &self,
        auth_client_token_request: models::AuthClientTokenRequest,
    ) -> Result<models::AuthClientTokenSuccess, Error<AuthClientsTokenPostError>>;

    /// POST /auth/login
    ///
    /// Interactive login endpoint for supported human-operated clients (`UI_WEB`, `UI_MOBILE`, and `AGENT`). Supports optional TOTP 2FA code when enabled.
    async fn auth_login_post<'auth_login_request>(
        &self,
        auth_login_request: models::AuthLoginRequest,
    ) -> Result<models::AuthLoginSuccess, Error<AuthLoginPostError>>;

    /// POST /auth/logout
    ///
    ///
    async fn auth_logout_post(&self) -> Result<(), Error<AuthLogoutPostError>>;

    /// POST /auth/lost-password/request
    ///
    ///
    async fn auth_lost_password_request_post<'auth_email_request>(
        &self,
        auth_email_request: models::AuthEmailRequest,
    ) -> Result<(), Error<AuthLostPasswordRequestPostError>>;

    /// POST /auth/lost-password/reset
    ///
    ///
    async fn auth_lost_password_reset_post<'auth_lost_password_reset_request>(
        &self,
        auth_lost_password_reset_request: models::AuthLostPasswordResetRequest,
    ) -> Result<(), Error<AuthLostPasswordResetPostError>>;

    /// GET /auth/me/features
    ///
    /// Returns user-level feature preferences (`user_feature_enabled`) and effective availability. Effective availability is computed with AND semantics: `feature_flags` AND `app_feature_enabled` AND `user_feature_enabled` AND dependency constraints.
    async fn auth_me_features_get(
        &self,
    ) -> Result<models::UserFeaturesResponse, Error<AuthMeFeaturesGetError>>;

    /// PATCH /auth/me/features
    ///
    /// Updates user-level feature preferences (`user_feature_enabled`) for the current authenticated user. Core v1 global features are protected and cannot be disabled at user scope.
    async fn auth_me_features_patch<'user_features_update_request>(
        &self,
        user_features_update_request: models::UserFeaturesUpdateRequest,
    ) -> Result<models::UserFeaturesResponse, Error<AuthMeFeaturesPatchError>>;

    /// GET /auth/me
    ///
    ///
    async fn auth_me_get(&self) -> Result<models::AuthCurrentUser, Error<AuthMeGetError>>;

    /// POST /auth/verify-email/admin-confirm
    ///
    /// Requires an authenticated admin actor, per AUTHZ matrix (FORBIDDEN_ACTOR or FORBIDDEN_SCOPE on authz failure).
    async fn auth_verify_email_admin_confirm_post<'auth_email_request>(
        &self,
        auth_email_request: models::AuthEmailRequest,
    ) -> Result<(), Error<AuthVerifyEmailAdminConfirmPostError>>;

    /// POST /auth/verify-email/confirm
    ///
    ///
    async fn auth_verify_email_confirm_post<'auth_token_request>(
        &self,
        auth_token_request: models::AuthTokenRequest,
    ) -> Result<(), Error<AuthVerifyEmailConfirmPostError>>;

    /// POST /auth/verify-email/request
    ///
    ///
    async fn auth_verify_email_request_post<'auth_email_request>(
        &self,
        auth_email_request: models::AuthEmailRequest,
    ) -> Result<(), Error<AuthVerifyEmailRequestPostError>>;
}

pub struct AuthApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl AuthApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

#[async_trait]
impl AuthApi for AuthApiClient {
    /// Returns global app switches (`app_feature_enabled`). Also returns dependency/escalation metadata for deterministic client behavior. Effective global availability requires Core `feature_flags` AND `app_feature_enabled`. Normative gate: when `app_feature_enabled.features.ai=false`, `client_kind=MCP` is disabled at runtime. Admin-only endpoint. Runtime payload contract is stable: `app_feature_enabled`, `feature_governance`, `core_v1_global_features`.
    async fn app_features_get(
        &self,
    ) -> Result<models::AppFeaturesResponse, Error<AppFeaturesGetError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/app/features", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppFeaturesResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AppFeaturesResponse`")))),
            }
        } else {
            let local_var_entity: Option<AppFeaturesGetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates effective app switches (`app_feature_enabled`). Admin-only operation.
    async fn app_features_patch<'app_features_update_request>(
        &self,
        app_features_update_request: models::AppFeaturesUpdateRequest,
    ) -> Result<models::AppFeaturesResponse, Error<AppFeaturesPatchError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/app/features", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };
        local_var_req_builder = local_var_req_builder.json(&app_features_update_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppFeaturesResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AppFeaturesResponse`")))),
            }
        } else {
            let local_var_entity: Option<AppFeaturesPatchError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns runtime `server_policy` including `feature_flags`. This endpoint is the canonical runtime policy transport for UI_WEB, UI_MOBILE, AGENT, and MCP clients. Clients may optionally send their supported feature-flags contract version for compatibility negotiation.
    async fn app_policy_get<'client_feature_flags_contract_version>(
        &self,
        client_feature_flags_contract_version: Option<&'client_feature_flags_contract_version str>,
    ) -> Result<models::AppPolicyResponse, Error<AppPolicyGetError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/app/policy", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref param_value) = client_feature_flags_contract_version {
            local_var_req_builder = local_var_req_builder.query(&[(
                "client_feature_flags_contract_version",
                &param_value.to_string(),
            )]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };
        if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppPolicyResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AppPolicyResponse`")))),
            }
        } else {
            let local_var_entity: Option<AppPolicyGetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth2fa_disable_post<'auth2fa_otp_request>(
        &self,
        auth2fa_otp_request: models::Auth2faOtpRequest,
    ) -> Result<(), Error<Auth2faDisablePostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/2fa/disable", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };
        local_var_req_builder = local_var_req_builder.json(&auth2fa_otp_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<Auth2faDisablePostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth2fa_enable_post<'auth2fa_otp_request>(
        &self,
        auth2fa_otp_request: models::Auth2faOtpRequest,
    ) -> Result<models::Auth2faEnableResponse, Error<Auth2faEnablePostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/2fa/enable", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };
        local_var_req_builder = local_var_req_builder.json(&auth2fa_otp_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Auth2faEnableResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::Auth2faEnableResponse`")))),
            }
        } else {
            let local_var_entity: Option<Auth2faEnablePostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth2fa_recovery_codes_regenerate_post(
        &self,
    ) -> Result<models::Auth2faRecoveryCodesResponse, Error<Auth2faRecoveryCodesRegeneratePostError>>
    {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/2fa/recovery-codes/regenerate",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Auth2faRecoveryCodesResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::Auth2faRecoveryCodesResponse`")))),
            }
        } else {
            let local_var_entity: Option<Auth2faRecoveryCodesRegeneratePostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Starts TOTP enrollment for external authenticator apps (Authy, Google Authenticator, 1Password, etc.). Returns provisioning material (`otpauth://` URI and secret) to be confirmed by `/auth/2fa/enable`.
    async fn auth2fa_setup_post(
        &self,
    ) -> Result<models::Auth2faSetupResponse, Error<Auth2faSetupPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/2fa/setup", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Auth2faSetupResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::Auth2faSetupResponse`")))),
            }
        } else {
            let local_var_entity: Option<Auth2faSetupPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Admin-only endpoint for base UI operations. Invalidates active bearer token(s) for the targeted technical client.
    async fn auth_clients_client_id_revoke_token_post<'client_id>(
        &self,
        client_id: &'client_id str,
    ) -> Result<models::AuthRevokeClientTokenResponse, Error<AuthClientsClientIdRevokeTokenPostError>>
    {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/clients/{client_id}/revoke-token",
            local_var_configuration.base_path,
            client_id = crate::apis::urlencode(client_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthRevokeClientTokenResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthRevokeClientTokenResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthClientsClientIdRevokeTokenPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Admin-only operation. Rotates secret key for one client and invalidates active bearer token(s).
    async fn auth_clients_client_id_rotate_secret_post<'client_id>(
        &self,
        client_id: &'client_id str,
    ) -> Result<
        models::AuthRotateClientSecretResponse,
        Error<AuthClientsClientIdRotateSecretPostError>,
    > {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/clients/{client_id}/rotate-secret",
            local_var_configuration.base_path,
            client_id = crate::apis::urlencode(client_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthRotateClientSecretResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthRotateClientSecretResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthClientsClientIdRotateSecretPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_clients_device_cancel_post<'auth_device_cancel_request>(
        &self,
        auth_device_cancel_request: models::AuthDeviceCancelRequest,
    ) -> Result<models::AuthDeviceCancelResponse, Error<AuthClientsDeviceCancelPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/clients/device/cancel",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_device_cancel_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthDeviceCancelResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthDeviceCancelResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthClientsDeviceCancelPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Polls authorization status for a previously started device flow. On approval, returns one-shot `secret_key`.
    async fn auth_clients_device_poll_post<'auth_device_poll_request>(
        &self,
        auth_device_poll_request: models::AuthDevicePollRequest,
    ) -> Result<models::AuthDevicePollResponse, Error<AuthClientsDevicePollPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/clients/device/poll",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_device_poll_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthDevicePollResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthDevicePollResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthClientsDevicePollPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Starts a browser-assisted authorization flow (GitHub-style) for `AGENT`/`MCP`. User validation (and optional 2FA) happens via `verification_uri`. Runtime gate: when `app_feature_enabled.features.ai=false`, `client_kind=MCP` MUST be rejected.
    async fn auth_clients_device_start_post<'auth_device_start_request>(
        &self,
        auth_device_start_request: models::AuthDeviceStartRequest,
    ) -> Result<models::AuthDeviceStartResponse, Error<AuthClientsDeviceStartPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/clients/device/start",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_device_start_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthDeviceStartResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthDeviceStartResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthClientsDeviceStartPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Exchanges `(client_id, secret_key)` for a bearer token. Normative rule: one active token per technical client_id; minting a new token revokes the previous one. This endpoint is for technical non-interactive clients only. Runtime gate: when `app_feature_enabled.features.ai=false`, `client_kind=MCP` MUST be rejected.
    async fn auth_clients_token_post<'auth_client_token_request>(
        &self,
        auth_client_token_request: models::AuthClientTokenRequest,
    ) -> Result<models::AuthClientTokenSuccess, Error<AuthClientsTokenPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/clients/token", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_client_token_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthClientTokenSuccess`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthClientTokenSuccess`")))),
            }
        } else {
            let local_var_entity: Option<AuthClientsTokenPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Interactive login endpoint for supported human-operated clients (`UI_WEB`, `UI_MOBILE`, and `AGENT`). Supports optional TOTP 2FA code when enabled.
    async fn auth_login_post<'auth_login_request>(
        &self,
        auth_login_request: models::AuthLoginRequest,
    ) -> Result<models::AuthLoginSuccess, Error<AuthLoginPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/login", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_login_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthLoginSuccess`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthLoginSuccess`")))),
            }
        } else {
            let local_var_entity: Option<AuthLoginPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_logout_post(&self) -> Result<(), Error<AuthLogoutPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/logout", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<AuthLogoutPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_lost_password_request_post<'auth_email_request>(
        &self,
        auth_email_request: models::AuthEmailRequest,
    ) -> Result<(), Error<AuthLostPasswordRequestPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/lost-password/request",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_email_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<AuthLostPasswordRequestPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_lost_password_reset_post<'auth_lost_password_reset_request>(
        &self,
        auth_lost_password_reset_request: models::AuthLostPasswordResetRequest,
    ) -> Result<(), Error<AuthLostPasswordResetPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/lost-password/reset",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_lost_password_reset_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<AuthLostPasswordResetPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns user-level feature preferences (`user_feature_enabled`) and effective availability. Effective availability is computed with AND semantics: `feature_flags` AND `app_feature_enabled` AND `user_feature_enabled` AND dependency constraints.
    async fn auth_me_features_get(
        &self,
    ) -> Result<models::UserFeaturesResponse, Error<AuthMeFeaturesGetError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/me/features", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserFeaturesResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::UserFeaturesResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthMeFeaturesGetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates user-level feature preferences (`user_feature_enabled`) for the current authenticated user. Core v1 global features are protected and cannot be disabled at user scope.
    async fn auth_me_features_patch<'user_features_update_request>(
        &self,
        user_features_update_request: models::UserFeaturesUpdateRequest,
    ) -> Result<models::UserFeaturesResponse, Error<AuthMeFeaturesPatchError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/me/features", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };
        local_var_req_builder = local_var_req_builder.json(&user_features_update_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserFeaturesResponse`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::UserFeaturesResponse`")))),
            }
        } else {
            let local_var_entity: Option<AuthMeFeaturesPatchError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_me_get(&self) -> Result<models::AuthCurrentUser, Error<AuthMeGetError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/auth/me", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthCurrentUser`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::AuthCurrentUser`")))),
            }
        } else {
            let local_var_entity: Option<AuthMeGetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Requires an authenticated admin actor, per AUTHZ matrix (FORBIDDEN_ACTOR or FORBIDDEN_SCOPE on authz failure).
    async fn auth_verify_email_admin_confirm_post<'auth_email_request>(
        &self,
        auth_email_request: models::AuthEmailRequest,
    ) -> Result<(), Error<AuthVerifyEmailAdminConfirmPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/verify-email/admin-confirm",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };
        local_var_req_builder = local_var_req_builder.json(&auth_email_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<AuthVerifyEmailAdminConfirmPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_verify_email_confirm_post<'auth_token_request>(
        &self,
        auth_token_request: models::AuthTokenRequest,
    ) -> Result<(), Error<AuthVerifyEmailConfirmPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/verify-email/confirm",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_token_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<AuthVerifyEmailConfirmPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn auth_verify_email_request_post<'auth_email_request>(
        &self,
        auth_email_request: models::AuthEmailRequest,
    ) -> Result<(), Error<AuthVerifyEmailRequestPostError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/auth/verify-email/request",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&auth_email_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<AuthVerifyEmailRequestPostError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed errors of method [`AuthApi::app_features_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppFeaturesGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::app_features_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppFeaturesPatchError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::app_policy_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppPolicyGetError {
    Status401(models::ErrorResponse),
    Status426(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth2fa_disable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Auth2faDisablePostError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status409(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth2fa_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Auth2faEnablePostError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status409(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth2fa_recovery_codes_regenerate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Auth2faRecoveryCodesRegeneratePostError {
    Status401(models::ErrorResponse),
    Status409(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth2fa_setup_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Auth2faSetupPostError {
    Status401(models::ErrorResponse),
    Status409(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_clients_client_id_revoke_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthClientsClientIdRevokeTokenPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_clients_client_id_rotate_secret_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthClientsClientIdRotateSecretPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_clients_device_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthClientsDeviceCancelPostError {
    Status400(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_clients_device_poll_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthClientsDevicePollPostError {
    Status400(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_clients_device_start_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthClientsDeviceStartPostError {
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_clients_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthClientsTokenPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_login_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthLoginPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_logout_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthLogoutPostError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_lost_password_request_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthLostPasswordRequestPostError {
    Status422(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_lost_password_reset_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthLostPasswordResetPostError {
    Status400(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_me_features_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthMeFeaturesGetError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_me_features_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthMeFeaturesPatchError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthMeGetError {
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_verify_email_admin_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthVerifyEmailAdminConfirmPostError {
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_verify_email_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthVerifyEmailConfirmPostError {
    Status400(models::ErrorResponse),
    Status422(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`AuthApi::auth_verify_email_request_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthVerifyEmailRequestPostError {
    Status422(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}
